name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0, patch, minor, major)'
        required: true
        default: 'patch'
        type: string
  push:
    branches: [main]

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Validate NPM Token
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "âŒ NPM_TOKEN secret is not set. Cannot proceed with release."
            echo "Please add NPM_TOKEN to your repository secrets before creating a release."
            exit 1
          else
            echo "âœ… NPM_TOKEN is set. Release can proceed."
          fi

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get current version
        id: current_version
        run: |
          current_version=$(node -p "require('./package.json').version")
          echo "current=$current_version" >> $GITHUB_OUTPUT

      - name: Analyze commits for version bump
        id: analyze_commits
        run: |
          # Get the latest tag (last release)
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$latest_tag" ]; then
            echo "No previous tags found - this will be the first release"
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ First release - defaulting to minor version bump"
            exit 0
          fi
          
          echo "Latest tag: $latest_tag"
          echo "Analyzing commits since $latest_tag..."
          
          # Get commits since last tag
          commits=$(git log --oneline --pretty=format:"%s" "$latest_tag"..HEAD)
          
          if [ -z "$commits" ]; then
            echo "No new commits since last release"
            echo "bump_type=none" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "New commits:"
          echo "$commits"
          
          # Initialize flags
          has_breaking=false
          has_feat=false
          has_fix=false
          
          # Analyze each commit
          while IFS= read -r commit; do
            echo "Analyzing: $commit"
            
            # Check for breaking changes
            if [[ "$commit" =~ BREAKING[[:space:]]CHANGE ]] || [[ "$commit" =~ ^[^:]+!: ]]; then
              echo "  â†’ Breaking change detected"
              has_breaking=true
            fi
            
            # Check for features
            if [[ "$commit" =~ ^feat(\(.+\))?: ]]; then
              echo "  â†’ Feature detected"
              has_feat=true
            fi
            
            # Check for fixes
            if [[ "$commit" =~ ^fix(\(.+\))?: ]]; then
              echo "  â†’ Fix detected"
              has_fix=true
            fi
          done <<< "$commits"
          
          # Determine version bump
          if [ "$has_breaking" = true ]; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "ðŸš¨ MAJOR version bump (breaking changes detected)"
          elif [ "$has_feat" = true ]; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "âœ¨ MINOR version bump (new features detected)"
          elif [ "$has_fix" = true ]; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "ðŸ› PATCH version bump (bug fixes detected)"
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "ðŸ“ PATCH version bump (other changes detected)"
          fi

      - name: Determine next version
        id: next_version
        run: |
          input_version="${{ github.event.inputs.version }}"
          current_version="${{ steps.current_version.outputs.current }}"
          
          # If triggered by push to main (automatic), use analyzed version bump
          if [ "${{ github.event_name }}" = "push" ]; then
            analyzed_bump="${{ steps.analyze_commits.outputs.bump_type }}"
            
            if [ "$analyzed_bump" = "none" ]; then
              echo "No new commits since last release - skipping release"
              echo "skip_release=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            input_version="$analyzed_bump"
            echo "ðŸ”„ Automatic release triggered - using $analyzed_bump version bump based on commit analysis"
          fi
          
          echo "skip_release=false" >> $GITHUB_OUTPUT
          
          if [[ "$input_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # Explicit version provided
            next_version="$input_version"
          elif [[ "$input_version" == "patch" ]]; then
            # Calculate patch version
            IFS='.' read -ra VERSION_PARTS <<< "$current_version"
            major=${VERSION_PARTS[0]}
            minor=${VERSION_PARTS[1]}
            patch=${VERSION_PARTS[2]}
            next_version="$major.$minor.$((patch + 1))"
          elif [[ "$input_version" == "minor" ]]; then
            # Calculate minor version
            IFS='.' read -ra VERSION_PARTS <<< "$current_version"
            major=${VERSION_PARTS[0]}
            minor=${VERSION_PARTS[1]}
            next_version="$major.$((minor + 1)).0"
          elif [[ "$input_version" == "major" ]]; then
            # Calculate major version
            IFS='.' read -ra VERSION_PARTS <<< "$current_version"
            major=${VERSION_PARTS[0]}
            next_version="$((major + 1)).0.0"
          else
            echo "Invalid version input: $input_version"
            exit 1
          fi
          
          echo "next=$next_version" >> $GITHUB_OUTPUT
          echo "Next version will be: $next_version"

      - name: Skip release if no changes
        if: steps.next_version.outputs.skip_release == 'true'
        run: |
          echo "ðŸš« No new commits since last release - skipping release process"
          exit 0

      - name: Run tests
        if: steps.next_version.outputs.skip_release != 'true'
        run: bun test

      - name: Build package
        if: steps.next_version.outputs.skip_release != 'true'
        run: bun run build

      - name: Generate changelog
        if: steps.next_version.outputs.skip_release != 'true'
        run: |
          # Initialize changelog if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            bun run changelog:init
          else
            bun run changelog
          fi

      - name: Update package version
        if: steps.next_version.outputs.skip_release != 'true'
        run: |
          next_version="${{ steps.next_version.outputs.next }}"
          # Update package.json version
          node -e "
            const pkg = require('./package.json');
            pkg.version = '$next_version';
            require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          
          # Stage the changes
          git add package.json CHANGELOG.md

      - name: Create release branch
        if: steps.next_version.outputs.skip_release != 'true'
        run: |
          next_version="${{ steps.next_version.outputs.next }}"
          timestamp=$(date +%s)
          release_branch="release/v$next_version-$timestamp"
          
          echo "Creating release branch: $release_branch"
          
          # Delete any existing release branch for this version (cleanup from failed runs)
          if git ls-remote --exit-code --heads origin "release/v$next_version" >/dev/null 2>&1; then
            echo "Deleting existing release branch: release/v$next_version"
            git push origin --delete "release/v$next_version" || true
          fi
          
          # Create and push new release branch
          git checkout -b "$release_branch"
          git commit -m "chore(release): v$next_version"
          git push origin "$release_branch"
          echo "release_branch=$release_branch" >> $GITHUB_ENV

      - name: Create Release Pull Request
        if: steps.next_version.outputs.skip_release != 'true'
        id: create_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const nextVersion = '${{ steps.next_version.outputs.next }}';
            const currentVersion = '${{ steps.current_version.outputs.current }}';
            const releaseBranch = process.env.release_branch;
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš€ Release v${nextVersion}`,
              head: releaseBranch,
              base: 'main',
              body: `## Release v${nextVersion}

            This is an automated release pull request.

            ### Changes
            - Updated version from \`${currentVersion}\` to \`${nextVersion}\`
            - Updated CHANGELOG.md with latest changes

            ### Version Bump Analysis
            ${{ steps.analyze_commits.outputs.bump_type == 'major' && 'ðŸš¨ **MAJOR**: Breaking changes detected' || 
               steps.analyze_commits.outputs.bump_type == 'minor' && 'âœ¨ **MINOR**: New features added' || 
               'ðŸ› **PATCH**: Bug fixes and improvements' }}

            ### What's Next
            - â³ Waiting for required status checks to pass
            - ðŸ”„ Will be auto-merged once checks are complete  
            - ðŸ·ï¸ Git tag will be created after merge
            - ðŸ“¦ Package will be published automatically

            ---
            *This PR was created automatically by the release workflow*`
            });
            
            console.log('Created release PR:', pr.html_url);
            
            return pr.number;

      - name: Wait for status checks and auto-merge
        if: steps.next_version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.create_pr.outputs.result }};
            const nextVersion = '${{ steps.next_version.outputs.next }}';
            
            console.log(`Waiting for status checks on PR #${prNumber}...`);
            
            // Give PR workflows time to be triggered
            console.log('Waiting 60 seconds for PR workflows to start...');
            await new Promise(resolve => setTimeout(resolve, 60000));
            
            // Wait for status checks to complete
            let checks_complete = false;
            let attempts = 0;
            const max_attempts = 30; // 15 minutes max
            
            while (!checks_complete && attempts < max_attempts) {
              attempts++;
              
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              console.log(`Attempt ${attempts}: Checking PR status...`);
              
              // Check if PR is mergeable
              if (pr.mergeable === true && pr.mergeable_state === 'clean') {
                console.log('PR is ready to merge!');
                checks_complete = true;
              } else {
                console.log(`PR not ready: mergeable=${pr.mergeable}, mergeable_state=${pr.mergeable_state}`);
                await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
              }
            }
            
            if (!checks_complete) {
              throw new Error('Status checks did not pass within the timeout period');
            }
            
            // Merge the PR
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash',
              commit_title: `chore(release): v${nextVersion}`,
              commit_message: `Release version ${nextVersion}\n\nAuto-merged by release workflow`
            });
            
            console.log('Successfully merged release PR');
            
            // Create the git tag on the merged commit
            // Get the merged commit SHA
            const { data: mergedPr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/v${nextVersion}`,
              sha: mergedPr.merge_commit_sha
            });
            
                         console.log(`Created tag v${nextVersion}`);
             
             // Clean up the release branch after successful merge
             const releaseBranch = process.env.release_branch;
             if (releaseBranch) {
               try {
                 await github.rest.git.deleteRef({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   ref: `heads/${releaseBranch}`
                 });
                 console.log(`Cleaned up release branch: ${releaseBranch}`);
               } catch (error) {
                 console.log(`Could not delete release branch (this is ok): ${error.message}`);
               }
             }
             
             return mergedPr.merge_commit_sha;

      - name: Extract changelog for release
        if: steps.next_version.outputs.skip_release != 'true'
        id: changelog
        run: |
          next_version="${{ steps.next_version.outputs.next }}"
          
          # Extract the changelog section for this version
          if [ -f CHANGELOG.md ]; then
            # Get content between the first two version headers
            changelog_content=$(awk -v version="$next_version" '
              /^##/ { 
                if (found && !version_found) {
                  version_found = 1;
                  next;
                }
                if ($0 ~ version) {
                  found = 1;
                  next;
                }
                if (found && version_found) {
                  exit;
                }
              }
              found && !version_found { print }
            ' CHANGELOG.md)
            
            if [ -z "$changelog_content" ]; then
              changelog_content="Changes for version $next_version"
            fi
          else
            changelog_content="Initial release"
          fi
          
          # Save changelog content to output
          {
            echo 'content<<EOF'
            echo "$changelog_content"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.next_version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: 'v${{ steps.next_version.outputs.next }}',
              name: 'Release v${{ steps.next_version.outputs.next }}',
              body: `## What's Changed
            
            ${{ steps.changelog.outputs.content }}
            
            **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${{ steps.current_version.outputs.current }}...v${{ steps.next_version.outputs.next }}`,
              draft: false,
              prerelease: false
            });
            console.log('Created release:', release.html_url);

      - name: Publishing Info
        if: steps.next_version.outputs.skip_release != 'true'
        run: |
          echo "ðŸš€ Release created successfully!"
          echo "ðŸ“¦ Package will be published automatically by the 'Publish Package' workflow"
          echo "ðŸ”— GitHub Package Registry: Always published"
          echo "ðŸ“¡ npm Registry: Published if NPM_TOKEN secret is configured" 
